1. convert_grammar: I did this by using a helper function to combine all rules that belongs to the same non-terminal expression together first, then do this through the list. To build the function, just leave non-terminal expression as a parameter.
2. parse_prefix: I did this by using two helper function, match_terminate and or_matcher. I got the idea from hint. Basically for each non-terminal, I need to try its right hand side one by one. If there is one that matched the fragment, then return Some. This is the idea of or_matcher. For each right hand side, I need to check all the expression that inside the right hand side to match the fragment. If one is not matched, return None.
The parse_prefix idea is to combine those two helper function together. Start with or_matcher, then apply match_terminate to each right hand side. When meet non-terminate expression inside the right hand side, then apply or_matcher to that non-terminate again.
The function is a highly recursive function, so I use the trick that the hint used, to pass an unknown function as a parameter. Another one is to apply match_terminate to the rest of list as a new accepter of or_matcher, like append_matcher. 
I append the derivation every time I apply right hand side to match_terminate, and it will only return the successful one which hanging on till the end.

There are 2 weaknesses of my solution. One is that the match is highly relied on the grammar. It won't find the best match that can match as much as possible, but only find the first accepted match. That means my solution will work fine on the grammar that has longest right hand side before shorter one. The other is that it cannot handle grammar like this : Expr -> [[N Expr; N Binop; N Expr];[N Term]]. It will run into Expr all the time and it will not give proper match. 
